<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>高级前端面试题</title>
    <link href="css/normalize.css" rel="stylesheet" type="text/css" media="all">
    <link href="css/layout.css" rel="stylesheet" type="text/css" media="all">
    <link href="css/autoc.css" rel="stylesheet" type="text/css" media="all">
    <link rel="stylesheet" type="text/css" href="css/style.css">
</head>

<body>
    <!-- 主容器 -->
    <section class="page">
        <!-- 头部 -->
        <header class="header">
            <h1 class="title" id="top">高级前端面试题</h1>
            <ul class="meta">
                <li>编写: 陈创杰</li>
                <li>时间: 2017-02-22</li>
            </ul>
        </header>
        <!-- 头部END -->
        <!-- 中间内容 -->
        <article class="article" id="article">
            <h2>web前端工程师掌握的技能</h2>
            <p> Web前端开发工程师，主要职责是利用(X)HTML/CSS/JavaScript/Flash等各种Web技术进行客户端产品的开发。完成客户端程序（也就是浏览器端）的开发，开发JavaScript以及Flash模块，同时结合后台开发技术模拟整体效果，进行丰富互联网的Web开发，致力于通过技术改善用户体验。</p>
            <h2>HTML面试题目</h2>
            <h3>1.HTML标签的语义化是指？</h3>
            <div class="codetwo">
                <p> 通过使用包含语的标签（如h1-h6）恰当地表示文档结构</p>
            </div>
            <h3>2.css命名的语义化是指：</h3>
            <div class="codetwo">
                <p> 为html标签添加有意义的class</p>
            </div>
            <h3>3.为什么要语义化</h3>
            <div class="code">
                <ul>
                    <li>去掉样式后页面呈现清晰的结构</li>
                    <li>盲人使用读屏器更好地阅读</li>
                    <li>搜索引擎更好地理解页面，有利于收录</li>
                    <li>便团队项目的可持续运作及维护</li>
                </ul>
            </div>
            <h3>4.简述一下你对HTML语义化的理解？</h3>
            <div class="code">
                <ul>
                    <li>用正确的标签做正确的事情</li>
                    <li>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析</li>
                    <li>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的</li>
                    <li>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO</li>
                    <li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解</li>
                </ul>
            </div>
            <h3>5.Doctype作用？标准模式与兼容模式各有什么区别?</h3>
            <div class="codetwo">
                <ul>
                    <li>
                        &lt;!DOCTYPE &gt;声明位于位于HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现</li>
                    <li>标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作</li>
                </ul>
            </div>
            <h3>6.HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？</h3>
            <div class="codetwo">
                <ul>
                    <li>
                        HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）</li>
                    <li>而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型</li>
                </ul>
            </div>
            <h3>7.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h3>
            <div class="codetwo">
                <ul>
                    <li>HT行内元素有：a b span img input select strong（强调的语气）</li>
                    <li>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p</li>
                    <li>常见的空元素:&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</li>
                </ul>
            </div>
            <h3>8.页面导入样式时，使用link和@import有什么区别？</h3>
            <div class="codetwo">
                <ul>
                    <li>link属于XHTML标签，除了加载CSS外，还能用于定义RSS,定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS</li>
                    <li>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载</li>
                    <li>import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题</li>
                </ul>
            </div>
            <h3>9.介绍一下你对浏览器内核的理解？</h3>
            <div class="code">
                <ul>
                    <li>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎</li>
                    <li>
                        渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核
                    </li>
                    <li>JS引擎则：解析和执行javascript来实现网页的动态效果</li>
                    <li>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎</li>
                </ul>
            </div>
            <h3>10.常见的浏览器内核有哪些?</h3>
            <div class="code">
                <ul>
                    <li>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</li>
                    <li>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</li>
                    <li>Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]</li>
                    <li>Webkit内核：Safari,Chrome等。 [ Chrome的Blink（WebKit的分支）]</li>
                </ul>
            </div>
            <h3>11.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h3>
            <div class="code" style="height: auto;">
                <ul>
                    <li>
                        <h4>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加</h4>
                        <ul>
                            <li>绘画 canvas</li>
                            <li>用于媒介回放的 video 和 audio 元素</li>
                            <li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失</li>
                            <li>sessionStorage 的数据在浏览器关闭后自动删除</li>
                            <li>语意化更好的内容元素，比如 article、footer、header、nav、section</li>
                            <li>表单控件，calendar、date、time、email、url、search</li>
                            <li>新的技术webworker, websocket, Geolocation</li>
                        </ul>
                    </li>
                    <li>
                        <h4>移除的元素：</h4>
                        <ul>
                            <li>纯表现的元素：basefont，big，center，font, s，strike，tt，u</li>
                            <li>对可用性产生负面影响的元素：frame，frameset，noframes</li>
                        </ul>
                    </li>
                    <li>
                        <h4>支持HTML5新标签：</h4>
                        <ul>
                            <li>IE8/IE7/IE6支持通过document.createElement方法产生的标签</li>
                            <li>可以利用这一特性让这些浏览器支持HTML5新标签</li>
                            <li>浏览器支持新标签后，还需要添加标签默认的样式</li>
                        </ul>
                    </li>
                    <li>
                        <h4>当然也可以直接使用成熟的框架、比如html5shim</h4>
                        <p>
                            &lt;!--[if lt IE 9]&gt;
                            <br/> &lt;script&gt; src="http://html5shim.googlecode.com /svn/trunk/html5.js" &lt;/script&gt;
                            <br/>&lt;![endif]--&gt;
                        </p>
                    </li>
                    <li>如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素</li>
                </ul>
            </div>
            <h3>12.HTML5的离线储存怎么使用，工作原理能不能解释一下？</h3>
            <div class="code" style="height: auto">
                <ul>
                    <li>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件</li>
                    <li>
                        原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示
                    </li>
                    <li>
                        <h4>如何使用：</h4>
                        <ul>
                            <li>页面头部像下面一样加入一个manifest的属性；</li>
                            <li>在cache.manifest文件的编写离线存储的资源</li>
                            <li>在离线状态时，操作window.applicationCache进行需求实现</li>
                        </ul>
                    </li>
                    <p style="background-color: #fafafa">
                        CACHE MANIFEST
                        <br/> #v0.11
                        <br/> CACHE:
                        <br/> js/app.js
                        <br/>css/style.css
                        <br/>NETWORK:
                        <br/> resourse/logo.png
                        <br/>FALLBACK:
                        <br/> / /offline.html
                    </p>
                </ul>
            </div>
            <h3>14.浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</h3>
            <div class="code">
                <ul>
                    <li>
                        在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。
                    </li>
                    <li>离线的情况下，浏览器就直接使用离线存储的资源。</li>
                </ul>
            </div>
            <h3>15.请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3>
            <div class="code">
                <ul>
                    <li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li>
                    <li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递</li>
                    <li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存</li>
                    <li>
                        <h4>存储大小：</h4>
                        <ul>
                            <li>cookie数据大小不能超过4k</li>
                            <li>sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li>
                        </ul>
                    </li>
                    <li>
                        <h4>有期时间：</h4>
                        <ul>
                            <li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li>
                            <li>sessionStorage 数据在当前浏览器窗口关闭后自动删除</li>
                            <li>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <h3>16.iframe有那些缺点？</h3>
            <div class="code">
                <ul>
                    <li>iframe会阻塞主页面的Onload事件</li>
                    <li>搜索引擎的检索程序无法解读这种页面，不利于SEO</li>
                    <li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li>
                    <li>
                        使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题
                    </li>
                </ul>
            </div>
            <h3>17.Label的作用是什么？是怎么用的？</h3>
            <div class="code">
                <ul>
                    <li>label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件</li>
                </ul>
            </div>
            <h3>18.HTML5的form如何关闭自动完成功能？</h3>
            <div class="code">
                <ul>
                    <li>给不想要提示的 form 或某个 input 设置为 autocomplete=off。</li>
                </ul>
            </div>
            <h3>19.如何实现浏览器内多个标签页之间的通信? (阿里)</h3>
            <div class="code">
                <ul>
                    <li>WebSocket、SharedWorker</li>
                    <li>也可以调用localstorge、cookies等本地存储方式</li>
                </ul>
            </div>
            <h3>20.webSocket如何兼容低浏览器？(阿里)</h3>
            <div class="code">
                <ul>
                    <li>Adobe Flash Socket 、</li>
                    <li>ActiveX HTMLFile (IE) 、</li>
                    <li>基于 multipart 编码发送 XHR 、</li>
                    <li>基于长轮询的 XHR</li>
                </ul>
            </div>
            <h3>21.页面可见性（Page Visibility API） 可以有哪些用途？</h3>
            <div class="code">
                <ul>
                    <li>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;</li>
                    <li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</li>
                </ul>
            </div>
            <h3>22.如何在页面上实现一个圆形的可点击区域？</h3>
            <div class="code">
                <ul>
                    <li>map+area或者svg</li>
                    <li>border-radius</li>
                    <li>纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</li>
                </ul>
            </div>
            <h3>23.实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果</h3>
            <div class="code">
                &lt;div style="height:1px;overflow:hidden;background:red"&gt;&lt;/div&gt;
            </div>
            <h3>24.网页验证码是干嘛的，是为了解决什么安全问题</h3>
            <div class="code">
                <ul>
                    <li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li>
                    <li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li>
                </ul>
            </div>
            <h3>25.title与h1的区别、b与strong的区别、i与em的区别？</h3>
            <div class="code">
                <ul>
                    <li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响</li>
                    <li>strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：会重读，而是展示强调内容</li>
                    <li>i内容展示为斜体，em表示强调的文本</li>
                </ul>
            </div>
            <h3>26.页面导入样式时，使用 link 和 @import 有什么区别？</h3>
            <div class="code">
                <ul>
                    <li>link 属于HTML标签，除了加载CSS外，还能用于定 RSS等；@import 只能用于加载CSS</li>
                    <li>页面加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载</li>
                    <li>@import 只在 IE5 以上才能被识别，而 link 是HTML标签，无兼容问题</li>
                </ul>
            </div>
            <h3>27.HTML5有哪些新特性？</h3>
            <div class="code">
                <ul>
                    <li>新增选择器 document.querySelector、document.querySelectorAll</li>
                    <li>拖拽释放(Drag and drop) API</li>
                    <li>媒体播放的 video 和 audio</li>
                    <li>本地存储 localStorage 和 sessionStorage</li>
                    <li>离线应用 manifest</li>
                    <li>桌面通知 Notifications</li>
                    <li>语意化标签 article、footer、header、nav、section</li>
                    <li>增强表单控件 calendar、date、time、email、url、search</li>
                    <li>地理位置 Geolocation</li>
                    <li>多任务 webworker</li>
                    <li>全双工通信协议 websocket</li>
                    <li>历史管理 history</li>
                    <li>跨域资源共享(CORS) Access-Control-Allow-Origin</li>
                    <li>页面可见性改变事件 visibilitychange</li>
                    <li>跨窗口通信 PostMessage</li>
                    <li>Form Data 对象</li>
                    <li>绘画 canvas</li>
                </ul>
            </div>
            <h3>28.如何处理HTML5新标签的浏览器兼容问题？</h3>
            <div class="code">
                <ul>
                    <li>通过 document.createElement 创建新标签</li>
                    <li>使用垫片 html5shiv.js</li>
                </ul>
            </div>
            <h3>28.如何区分 HTML 和 HTML5？</h3>
            <div class="code">
                <ul>
                    <li>DOCTYPE声明、新增的结构元素、功能元素</li>
                </ul>
            </div>
            <h3>29.HTML5的离线储存工作原理能不能解释一下，怎么使用？</h3>
            <div class="code">
                <ul>
                    <li>
                        <h4>HTML5的离线储存原理：</h4>
                        <ul>
                            <li>用户在线时，保存更新用户机器上的缓存文件；当用户离线时，可以正常访离线储存问站点或应用内容</li>
                        </ul>
                    </li>
                    <li>
                        <h4>HTML5的离线储存使用:</h4>
                        <ul>
                            <li>在文档的 html 标签设置 manifest 属性，如 manifest="/offline.appcache"</li>
                            <li>在项目中新建 manifest 文件，manifest 文件的命名建议：xxx.appcache</li>
                            <li>在 web 服务器配置正确的 MIME-type，即 text/cache-manifest</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <h3>30.浏览器是怎么对HTML5的离线储存资源进行管理和加载的？</h3>
            <div class="code">
                <ul>
                    <li>在线的情况下，浏览器发现 html 标签有 manifest 属性，它会请求 manifest 文件</li>
                    <li>如果是第一次访问app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储</li>
                    <li>如果已经访问过app且资源已经离线存储了，浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作。如果文件改变了，那么就会重新下载文件中的资源并进行离线存储</li>
                    <li>离线的情况下，浏览器就直接使用离线存储的资源。</li>
                </ul>
            </div>
            <h3>31.iframe 有那些优点和缺点？</h3>
            <div class="code">
                <ul>
                    <li>
                        <h4>优点：</h4>
                        <ul>
                            <li>用来加载速度较慢的内容（如广告）</li>
                            <li>可以使脚本可以并行下载</li>
                            <li>可以实现跨子域通信</li>
                        </ul>
                    </li>
                    <li>
                        <h4>缺点:</h4>
                        <ul>
                            <li>iframe 会阻塞主页面的 onload 事件</li>
                            <li>无法被一些搜索引擎索识别</li>
                            <li>会产生很多页面，不容易管理</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <h2>CSS面试题目</h2>
            <h3>1.介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h3>
            <div class="code">
                <ul>
                    <li>有两种， IE 盒子模型、W3C 盒子模型；</li>
                    <li>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；</li>
                    <li>区 别： IE的content部分把 border 和 padding计算了进去;</li>
                </ul>
            </div>
            <h3>2.CSS选择符有哪些？哪些属性可以继承？</h3>
            <div class="code">
                <ul>
                    <li>id选择器（ # myid）</li>
                    <li>类选择器（.myclassname）</li>
                    <li>标签选择器（div, h1, p）</li>
                    <li>相邻选择器（h1 + p）</li>
                    <li>子选择器（ul > li）</li>
                    <li>后代选择器（li a）</li>
                    <li>通配符选择器（ * ）</li>
                    <li>属性选择器（a[rel = "external"]）</li>
                    <li>伪类选择器（a:hover, li:nth-child）</li>
                    <li>可继承的样式： font-size font-family color, UL LI DL DD DT</li>
                    <li>不可继承的样式：border padding margin width height</li>
                </ul>
            </div>
            <h3>3.CSS优先级算法如何计算？</h3>
            <div class="code">
                <ul>
                    <li>优先级就近原则，同权重情况下样式定义最近者为准</li>
                    <li>载入样式以最后载入的定位为准</li>
                    <li>
                        <h4>优先级为:</h4>
                        <ul>
                            <li>同权重: 内联样式表（标签内部）> 嵌入样式表（当前文件中）> 外部样式表（外部文件中）。</li>
                            <li>!important > id > class > tag</li>
                            <li>important 比 内联优先级高</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <h3>4.CSS3新增伪类有那些？</h3>
            <div class="code">
                <ul>
                    <li>p:first-of-type 选择属于其父元素的首个
                        <br/>元素的每个
                        <br/>元素。</li>
                    <li>p:last-of-type 选择属于其父元素的最后
                        <br/>元素的每个
                        <br/>元素。</li>
                    <li>p:only-of-type 选择属于其父元素唯一的
                        <br/>元素的每个
                        <br/>元素。</li>
                    <li>p:only-child 选择属于其父元素的唯一子元素的每个元素。</li>
                    <li>p:nth-child(2) 选择属于其父元素的第二个子元素的每个元素。</li>
                    <li>:after 在元素之前添加内容,也可以用来做清除浮动。</li>
                    <li>:before 在元素之后添加内容</li>
                    <li>:enabled</li>
                    <li>:disabled 控制表单控件的禁用状态。</li>
                    <li>:checked 单选框或复选框被选中</li>
                </ul>
            </div>
            <h3>5.如何居中div？</h3>
            <div class="code">
                <ul>
                    <li>水平居中：给div设置一个宽度，然后添加margin:0 auto属性</li>
                    <p class="bgcolor">
                        div{
                        <br/>width:200px;
                        <br/>margin:0 auto;
                        <br/>}
                    </p>
                    <li>让绝对定位的div居中</li>
                    <p class="bgcolor">
                        div {
                        <br/>position: absolute;
                        <br/> width: 300px;
                        <br/> height: 300px;
                        <br/> margin: auto;
                        <br/> top: 0;
                        <br/> left: 0;
                        <br/> bottom: 0;
                        <br/> right: 0;
                        <br/> background-color: pink; /* 方便看效果 */
                        <br/>}
                    </p>
                    <li>
                        <h4>水平垂直居中一</h4>
                        <ul>
                            <li>确定容器的宽高 宽500 高 300 的层</li>
                            <li>设置层的外边距</li>
                        </ul>
                    </li>
                    <p class="bgcolor">
                        div {
                        <br/> position: relative;/* 相对定位或绝对定位均可 */ width:500px;
                        <br/> height:300px;
                        <br/> top: 50%;
                        <br/> left: 50%;
                        <br/> margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */
                        <br/>background-color: pink;/* 方便看效果 */
                        <br/>}
                    </p>
                    <li>
                        <h4>水平垂直居中二</h4>
                        <ul>
                            <li>未知容器的宽高，利用 transform 属性</li>
                        </ul>
                    </li>
                    <p class="bgcolor">
                        div {
                        <br/> position: relative;/* 相对定位或绝对定位均可 */ width:500px;
                        <br/> height:300px;
                        <br/> top: 50%;
                        <br/> left: 50%;
                        <br/> transform: translate(-50%, -50%);
                        <br/>background-color: pink;/* 方便看效果 */
                        <br/>}
                    </p>
                    <li>
                        <h4>水平垂直居中三</h4>
                        <ul>
                            <li>利用 flex 布局</li>
                            <li>实际使用时应考虑兼容性</li>
                        </ul>
                    </li>
                    <p class="bgcolor">
                        .container {
                        <br/> display: flex;
                        <br/> align-items: center; /* 垂直居中 */
                        <br/> justify-content: center; /* 水平居中 */
                        <br/> }
                        <br/> .container div {
                        <br/> width: 100px;
                        <br/> height: 100px;
                        <br/> background-color: pink; /* 方便看效果 */
                        <br/> }
                        <br/>
                    </p>
                </ul>
            </div>
            <h3>5.display有哪些值？说明他们的作用。</h3>
            <div class="code">
                <ul>
                    <li>block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li>
                    <li>none 缺省值。象行内元素类型一样显示</li>
                    <li>inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示</li>
                    <li>inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。</li>
                    <li>list-item 象块类型元素一样显示，并添加样式列表标记。</li>
                    <li>table 此元素会作为块级表格来显示。</li>
                    <li>inherit 规定应该从父元素继承 display 属性的值</li>
                </ul>
            </div>
            <h3>6.display有哪些值？说明他们的作用。</h3>
            <div class="code">
                <ul>
                    <li>block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li>
                    <li>none 缺省值。象行内元素类型一样显示</li>
                    <li>inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示</li>
                    <li>inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。</li>
                    <li>list-item 象块类型元素一样显示，并添加样式列表标记。</li>
                    <li>table 此元素会作为块级表格来显示。</li>
                    <li>inherit 规定应该从父元素继承 display 属性的值</li>
                </ul>
            </div>
            <h3>7.CSS3有哪些新特性？</h3>
            <div class="code">
                <ul>
                    <li>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</li>
                    <li>圆角 （border-radius:8px）</li>
                    <li>多列布局 （multi-column layout）</li>
                    <li>阴影和反射 （Shadow\Reflect）</li>
                    <li>文字特效 （text-shadow、）</li>
                    <li>文字渲染 （Text-decoration）</li>
                    <li>线性渐变 （gradient）</li>
                    <li>旋转 （transform）</li>
                    <li>缩放,定位,倾斜,动画,多背景</li>
                    <li>例如:transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</li>
                </ul>
            </div>
            <h3>8.请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</h3>
            <div class="code">
                <ul>
                    <li>一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间</li>
                    <li>较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现</li>
                    <li>采用Flex布局的元素，称为Flex容器（flex container），简称"容器"。</li>
                    <li>它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称"项目"</li>
                    <li>常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应</li>
                    <li>在布局上有了比以前更加灵活的空间</li>
                </ul>
            </div>
            <h3>9.css多列等高如何实现？</h3>
            <div class="code">
                <ul>
                    <li>利用padding-bottom|margin-bottom正负值相抵；</li>
                    <li>设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度</li>
                    <li>当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度</li>
                    <li>其他比这列矮的列会用它们的padding-bottom补偿这部分高度差</li>
                </ul>
            </div>
            <h3>10.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧?</h3>
            <div class="code">
                <ul>
                    <li>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8</li>
                    <li>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一</li>
                    <li>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大</li>
                    <li>浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}</li>
                    <li>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——display:inline;将其转化为行内属性。(这个符号只有ie6会识别)</li>
                    <li>渐进识别的方式，从总体中逐渐排除局部</li>
                    <li>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来</li>
                    <li>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别</li>
                    <p class="bgcolor">
                        .bb{
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp;background-color:red;/*所有识别*/
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp;background-color:#00deff\9; /*IE6、7、8识别*/
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp;+background-color:#a200ff;/*IE6、7识别*/
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp;_background-color:#1e0bd1;/*IE6识别*/
                        <br/> }
                        <br/>
                    </p>
                </ul>
            </div>
            <h3>11.Firefox下,只能使用getAttribute()获取自定义属性</h3>
            <div class="code">
                <ul>
                    <li>解决方法:统一通过getAttribute()获取自定义属性。</li>
                </ul>
            </div>
            <h3>12.IE下,even对象有x,y属性,但是没有pageX,pageY属性</h3>
            <h3>13.Firefox下,event对象有pageX,pageY属性,但是没有x,y属性</h3>
            <h3>14.Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,</h3>
            <h3>15.超链接访问过后hover样式就不出现了。被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:</h3>
            <div class="code">
                <ul>
                    <li>L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}</li>
                </ul>
            </div>
            <h3>16.li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3>
            <div class="code">
                <ul>
                    <li>
                        行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了
                    </li>
                </ul>
            </div>
            <h3>17.为什么要初始化CSS样式</h3>
            <div class="code">
                <ul>
                    <li>
                        因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异
                    </li>
                    <li>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化</li>
                    <li>最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议）</li>
                </ul>
            </div>
            <h3>18.CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？</h3>
            <div class="code">
                <ul>
                    <li>
                        对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同.
                    </li>
                    <li>如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间.</li>
                    <li>仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间.</li>
                </ul>
            </div>
            <h3>19.position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？</h3>
            <div class="code">
                <ul>
                    <li>如果元素的display为none,那么元素不被渲染,position,float不起作用,</li>
                    <li>如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位,float不起作用.</li>
                    <li>如果元素float属性不是none,元素会脱离文档流,根据float属性值来显示.有浮动,绝对定位,inline-block属性的元素,margin不会和垂直方向上的其他元素margin折叠</li>
                </ul>
            </div>
            <h3>20.position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？</h3>
            <div class="code">
                <ul>
                    <li>css定义的权重</li>
                    <p class="bgcolor">
                        /*权重为1*/
                        <br/> div{
                        <br/> }
                        <br/> /*权重为10*/
                        <br/> .class1{
                        <br/> }
                        <br/> /*权重为100*/
                        <br/> #id1{
                        <br/> }
                        <br/> /*权重为100+1=101*/
                        <br/> #id1 div{
                        <br/> }
                        <br/> /*权重为10+1=11*/
                        <br/> .class1 div{
                        <br/> }
                        <br/> /*权重为10+10+1=21*/
                        <br/> .class1 .class2 div{
                        <br/> }
                    </p>
                </ul>
            </div>
            <h3>21.请解释一下为什么需要清除浮动？清除浮动的方式</h3>
            <div class="code">
                <ul>
                    <li>清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示</li>
                    <li>父级div定义height</li>
                    <li>父级div 也一起浮动；</li>
                    <li>常规的使用一个class；</li>
                    <p class="bgcolor">
                        .clearfix:before, .clearfix:after {
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp;content: " ";
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp;display: table;
                        <br/> }
                        <br/> .clearfix:after {
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp;clear: both;
                        <br/> }
                        <br/> .clearfix {
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp;*zoom: 1;
                        <br/> }
                    </p>
                </ul>
            </div>
            <h3>22.zoom:1的清除浮动原理?</h3>
            <div class="code">
                <ul>
                    <li>清除浮动，触发hasLayout；</li>
                    <li>Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug</li>
                    <li>譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等</li>
                </ul>
            </div>
            <h3>23.CSS优化、提高性能的方法有哪些？</h3>
            <div class="code">
                <ul>
                    <li>关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；</li>
                    <li>如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；</li>
                    <li>提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;</li>
                    <li>使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）</li>
                </ul>
            </div>
            <h3>24.浏览器是怎样解析CSS选择器的？</h3>
            <div class="code">
                <ul>
                    <li>样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素</li>
                    <li>只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则</li>
                </ul>
            </div>
            <h3>25.margin和padding分别适合什么场景使用？</h3>
            <div class="code">
                <ul>
                    <li>margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。</li>
                    <li>margin用于布局分开元素使元素与元素互不相干；</li>
                    <li>padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段</li>
                </ul>
            </div>
            <h3>26.::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用</h3>
            <div class="code">
                <ul>
                    <li>单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）</li>
                    <li>双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法</li>
                    <li>比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。</li>
                    <li>想让插入的内容出现在其它内容前，使用::before，否者，使用::after；在代码顺序上，::after生成的内容也比::before生成的内容靠后。</li>
                    <li>如果按堆栈视角，::after生成的内容会在::before生成的内容之上</li>
                </ul>
            </div>
            <h3>27.position:fixed;在android下无效怎么处理？</h3>
            <div class="code">
                <ul>
                    <li>fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，原来的网页还好好的在那，fixed的内容也没有变过位置，</li>
                    <li>所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的</li>
                    <li>比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。</li>
                    <p class="bgcolor">
                        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"/&gt;
                    </p>
                </ul>
            </div>
            <h3>28.display:inline-block 什么时候会显示间隙？</h3>
            <div class="code">
                <ul>
                    <li>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</li>
                </ul>
            </div>
            <h3>29.什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）</h3>
            <div class="code">
                <ul>
                    <li>如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开。</li>
                    <li>因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的</li>
                    <li>同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，提高了webserver的http请求的解析速度。</li>
                </ul>
            </div>
            <h3>30.什么是CSS 预处理器 / 后处理器？</h3>
            <div class="code">
                <ul>
                    <li>预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</li>
                    <li>后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</li>
                </ul>
            </div>
            <h2>JavaScript</h2>
            <h3>1.介绍js的基本数据类型</h3>
            <div class="code">
                Undefined、Null、Boolean、Number、String、 ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )
            </div>
            <h3>2.介绍js有哪些内置对象？</h3>
            <div class="code">
                <ul>
                    <li>Object 是 JavaScript 中所有对象的父对象</li>
                    <li>数据封装类对象：Object、Array、Boolean、Number 和 String</li>
                    <li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li>
                </ul>
            </div>
            <h3>3.说几条写JavaScript的基本规范？</h3>
            <div class="code">
                <ul>
                    <li>不要在同一行声明多个变量</li>
                    <li>请使用 ===/!==来比较true/false或者数值</li>
                    <li>使用对象字面量替代new Array这种形式</li>
                    <li>不要使用全局函数</li>
                    <li>Switch语句必须带有default分支</li>
                    <li>函数不应该有时候有返回值，有时候没有返回值。</li>
                    <li>For循环必须使用大括号</li>
                    <li>If语句必须使用大括号</li>
                    <li>for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</li>
                </ul>
            </div>
            <h3>4.JavaScript原型，原型链 ? 有什么特点？</h3>
            <div class="code">
                <ul>
                    <li>
                        每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。
                    </li>
                    <li>关系：instance.constructor.prototype = instance.proto</li>
                    <li>特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</li>
                    <li>
                        当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话， 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。
                    </li>
                    <p class="bgcolor">
                        function Func(){}
                        <br/> Func.prototype.name = "Sean";
                        <br/> Func.prototype.getInfo = function() {
                        <br/> return this.name;
                        <br/> }
                        <br/> var person = new Func();//现在可以参考var person = Object.create(oldObject);
                        <br/> console.log(person.getInfo());//它拥有了Func的属性和方法
                        <br/> //"Sean"
                        <br/> console.log(Func.prototype);
                        <br/> // Func { name="Sean", getInfo=function()}
                    </p>
                </ul>
            </div>
            <h3>5.JavaScript有几种类型的值？，你能画一下他们的内存图吗？</h3>
            <div class="code">
                <ul>
                    <li>栈：原始数据类型（Undefined，Null，Boolean，Number、String）</li>
                    <li>堆：引用数据类型（对象、数组和函数）</li>
                    <li>
                        <h4>两种类型的区别是：存储位置不同</h4>
                        <ul>
                            <li>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>
                        </ul>
                    </li>
                    <li>
                        引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体
                    </li>
                </ul>
            </div>
            <h3>6.Javascript如何实现继承？</h3>
            <div class="code">
                <ul>
                    <li>构造继承</li>
                    <li>原型继承</li>
                    <li>实例继承</li>
                    <li>拷贝继承</li>
                    <li>原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式</li>
                    <p class="bgcolor">
                        function Parent(){
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp;this.name = 'wang';
                        <br/> }
                        <br/>
                        <br/> function Child(){
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp;this.age = 28;
                        <br/> }
                        <br/> Child.prototype = new Parent();//继承了Parent，通过原型
                        <br/>
                        <br/> var demo = new Child();
                        <br/> alert(demo.age);
                        <br/> alert(demo.name);//得到被继承的属性
                    </p>
                </ul>
            </div>
            <h3>7.javascript创建对象的几种方式？</h3>
            <div class="code">
                <ul>
                    <li>javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用</li>
                    <li>对象字面量的方式</li>
                    <p class="bgcolor">
                        person={firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"};
                    </p>
                    <li>用function来模拟无参的构造函数</li>
                    <p class="bgcolor">
                        function Person(){}
                        <br/> //定义一个function，如果使用new"实例化",该function可以看作是一个Class
                        <br/> person.name="Mark";
                        <br/> var person=new Person();
                        <br/> person.age="25";
                        <br/> person.work=function(){
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp;alert(person.name+" hello...");
                        <br/> }
                        <br/> person.work();
                    </p>
                    <li>用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</li>
                    <p class="bgcolor">
                        function Pet(name,age,hobby){
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp;this.name=name;//this作用域：当前对象
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp;this.age=age;
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp;this.hobby=hobby;
                        <br/> this.eat=function(){
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp;alert("我叫"+this.name+",我喜欢"+this.hobby+",是个程序员");
                        <br/> &nbsp;&nbsp;}
                        <br/> }
                        <br/> var maidou =new Pet("麦兜",25,"coding");//实例化、创建对象
                        <br/> maidou.eat();//调用eat方法
                        <br/>
                    </p>
                    <li>用工厂方式来创建（内置对象）</li>
                    <p class="bgcolor">
                        var wcDog =new Object(); wcDog.name="旺财";
                        <br/> wcDog.age=3;
                        <br/> wcDog.work=function(){
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp; alert("我是"+wcDog.name+",汪汪汪......");
                        <br/> }
                        <br/> wcDog.work();
                    </p>
                    <li>用原型方式来创建</li>
                    <p class="bgcolor">
                        function Dog(){
                        <br/> }
                        <br/> Dog.prototype.name="旺财";
                        <br/> Dog.prototype.eat=function(){
                        <br/> alert(this.name+"是个吃货");
                        <br/> }
                        <br/> var wangcai =new Dog();
                        <br/> wangcai.eat();
                    </p>
                    <li>用混合方式来创建</li>
                    <p class="bgcolor">
                        function Car(name,price){
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp; this.name=name;
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp; this.price=price;
                        <br/> }
                        <br/> Car.prototype.sell=function(){
                        <br/> &nbsp;&nbsp;&nbsp;&nbsp; alert("我是"+this.name+"，我现在卖"+this.price+"万元");
                        <br/> }
                        <br/> var camry =new Car("凯美瑞",27);
                        <br/> camry.sell();
                    </p>
                    <li>If语句必须使用大括号</li>
                    <li>for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</li>
                </ul>
            </div>
            <h3>8.Javascript作用链域?</h3>
            <div class="code">
                <ul>
                    <li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。</li>
                    <li>
                        当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链
                    </li>
                </ul>
            </div>
            <h3>9.谈谈This对象的理解?</h3>
            <div class="code">
                <ul>
                    <li>this总是指向函数的直接调用者（而非间接调用者）；</li>
                    <li>如果有new关键字，this指向new出来的那个对象 </li>
                    <li>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window</li>
                </ul>
            </div>
            <h3>10.eval是做什么的？?</h3>
            <div class="code">
                <ul>
                    <li>它的功能是把对应的字符串解析成JS代码并运行；</li>
                    <li>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） </li>
                    <li>由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')');</li>
                </ul>
            </div>
            <h3>11.什么是window对象? 什么是document对象?</h3>
            <div class="code">
                <ul>
                    <li>window对象是指浏览器打开的窗口。</li>
                    <li>document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性 </li>
                </ul>
            </div>
            <h3>12.null，undefined 的区别？</h3>
            <div class="code">
                <ul>
                    <li>null 表示一个对象是“没有值”的值，也就是值为“空”；</li>
                    <li>undefined 表示一个变量声明了没有初始化(赋值)；</li>
                    <li>undefined不是一个有效的JSON，而null是；</li>
                    <li>undefined的类型(typeof)是undefined；</li>
                    <li>null的类型(typeof)是object；</li>
                    <li>Javascript将未赋值的变量默认值设为undefined；</li>
                    <li>Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的</li>
                    <li>typeof undefined</li>
                    <p class="bgcolor">
                        <ul>
                            <li>
                                undefined :
                                <ul>
                                    <li>是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined；</li>
                                    <li>例如变量被声明了，但没有赋值时，就等于undefined</li>
                                </ul>
                            </li>
                        </ul>
                    </p>
                    <li>typeof null //"object"</li>
                    <p class="bgcolor">
                        <ul>
                            <li>null : 是一个对象(空对象, 没有任何属性和方法)；</li>
                            <li>例如作为函数的参数，表示该函数的参数不是对象；</li>
                        </ul>
                    </p>
                    <li>注意：</li>
                    <p class="bgcolor">
                        <ul>
                            <li>在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</li>
                            <li>null == undefined // true</li>
                            <li>null === undefined // false</li>
                        </ul>
                    </p>
                </ul>
            </div>
            <h3>13.什么是闭包（closure），为什么要用它？</h3>
            <div class="code">
                <ul>
                    <li>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部</li>
                    <li>
                        闭包的特性：
                        <ul>
                            <li>函数内再嵌套函数</li>
                            <li>内部函数可以引用外层的参数和变量</li>
                            <li>参数和变量不会被垃圾回收机制回收</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <h3>14.javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？</h3>
            <div class="code">
                <ul>
                    <li>use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,</li>
                    <li>使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。</li>
                    <li>默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;</li>
                    <li>全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；</li>
                    <li>消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;</li>
                    <li>提高编译器效率，增加运行速度；为未来新版本的Javascript标准化做铺垫。</li>
                </ul>
            </div>
            <h3>15.new操作符具体干了什么呢?</h3>
            <div class="code">
                <ul>
                    <li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li>
                    <li>属性和方法被加入到 this 引用的对象中。</li>
                    <li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li>
                    <p class="bgcolor">
                        var obj = {};
                        <br/> obj.__proto__ = Base.prototype;
                        <br/> Base.call(obj);
                    </p>
                </ul>
            </div>
            <h3>16.JSON 的了解?</h3>
            <div class="code">
                <ul>
                    <li>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。</li>
                    <li>它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小</li>
                    <li>如：{"age":"12", "name":"back"}</li>
                    <li>JSON字符串转换为JSON对象:</li>
                    <p class="bgcolor">
                        var obj =eval('('+ str +')');
                        <br/> var obj = str.parseJSON();
                        <br/> var obj = JSON.parse(str);
                        <br/>
                        <br/> JSON对象转换为JSON字符串：
                        <br/> var last=obj.toJSONString();
                        <br/> var last=JSON.stringify(obj);
                    </p>
                </ul>
            </div>
            <h3>16.Ajax 是什么? 如何创建一个Ajax？</h3>
            <div class="code">
                <ul>
                    <li>ajax的全称：Asynchronous Javascript And XML。</li>
                    <li>异步传输+js+xml</li>
                    <li>
                        所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验
                    </li>
                    <li>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象</li>
                    <li>(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</li>
                    <li>(3)设置响应HTTP请求状态变化的函数</li>
                    <li>(4)发送HTTP请求</li>
                    <li>(5)获取异步调用返回的数据</li>
                    <li>(6)使用JavaScript和DOM实现局部刷新</li>
                </ul>
            </div>
            <h3>17.Ajax 解决浏览器缓存问题？</h3>
            <div class="code">
                <ul>
                    <li>1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader("If-Modified-Since","0")。</li>
                    <li>2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader("Cache-Control","no-cache")。</li>
                    <li>3、在URL后面加上一个随机数： "fresh=" + Math.random();。</li>
                    <li>4、在URL后面加上时间搓："nowtime=" + new Date().getTime();。</li>
                    <li>5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录</li>
                </ul>
            </div>
            <h3>18.同步和异步的区别?</h3>
            <div class="code">
                <ul>
                    <li>
                        同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.
                    </li>
                    <li>
                        同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作
                    </li>
                    <li>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li>
                </ul>
            </div>
            <h3>19.针对 jQuery 的优化方法?</h3>
            <div class="code">
                <ul>
                    <li>基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。</li>
                    <li>频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好</li>
                    <p class="bgcolor">
                        比如：var str=$("a").attr("href");
                    </p>
                    <li>for (var i = size; i
                        < arr.length; i++) {}</li>
                            <p class="bgcolor">
                                for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：
                                <br/> for (var i = size, length = arr.length; i
                                < length; i++) {} </p>
                </ul>
            </div>
            <h3>20.那些操作会造成内存泄漏？</h3>
            <div class="code">
                <ul>
                    <li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li>
                    <li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收</li>
                    <li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环)</li>
                </ul>
            </div>
            <h3>21.jquery.extend 与 jquery.fn.extend的区别？</h3>
            <div class="code">
                <ul>
                    <li>jquery.extend 为jquery类添加类方法，可以理解为添加静态方法</li>
                    <li>jquery.fn.extend:源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数 使用：</li>
                    <li>jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用</li>
                </ul>
            </div>
            <h3>22.Jquery与jQuery UI 有啥区别？</h3>
            <div class="code">
                <ul>
                    <li>jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等</li>
                    <li>jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件</li>
                    <li>提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等</li>
                </ul>
            </div>
            <h3>23.Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？</h3>
            <div class="code">
                <ul>
                    <li>两等号判等，会在比较时进行类型转换；</li>
                    <li>三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）；</li>
                    <li>Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true</li>
                    <li>Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</li>
                </ul>
            </div>
            <h3>24.页面重构怎么操作？</h3>
            <div class="code">
                <ul>
                    <li>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI</li>
                    <li>
                        对于传统的网站来说重构通常是：
                        <ul>
                            <li>表格(table)布局改为DIV+CSS</li>
                            <li>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)</li>
                            <li>对于移动平台的优化</li>
                            <li>针对于SEO进行优化</li>
                            <li>深层次的网站重构应该考虑的方面</li>
                            <li>减少代码间的耦合</li>
                            <li>让代码保持弹性</li>
                            <li>严格按规范编写代码</li>
                            <li>设计可扩展的API</li>
                            <li>代替旧有的框架、语言(如VB)</li>
                            <li>增强用户体验</li>
                            <li>通常来说对于速度的优化也包含在重构中</li>
                            <li>压缩JS、CSS、image等前端资源(通常是由服务器来解决)</li>
                            <li>程序的性能优化(如数据读写)</li>
                            <li>采用CDN来加速资源加载</li>
                            <li>对于JS DOM的优化</li>
                            <li>HTTP服务器的文件缓存</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <h3>25.WEB应用从服务器主动推送Data到客户端有那些方式？</h3>
            <div class="code">
                <ul>
                    <li>html5提供的Websocket</li>
                    <li>不可见的iframe</li>
                    <li>WebSocket通过Flash</li>
                    <li>XHR长时间连接</li>
                    <li>XHR Multipart Streaming</li>
                </ul>
            </div>
            <h2>繼續努力</h2>
        </article>
        <!-- 中间内容END -->
        <!-- 底部 -->
        <footer class="copyright ">
            <p><i class="toc-icon "></i>Copyright &copy; 2017 <a href="http://www.jikexueyuan.com/">WEB题库</a>, WEB高级前端工程师.</p>
        </footer>
        <!-- 底部END -->
    </section>
    <!-- 主容器 -->
</body>
<script type="text/javascript " src="js/jquery.js "></script>
<script type="text/javascript " src="js/autoc.js "></script>
<script type="text/javascript ">
// jquery 插件
$('#article').autoc();
</script>

</html>
